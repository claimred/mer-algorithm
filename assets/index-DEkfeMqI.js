var q=Object.defineProperty;var K=(a,t,e)=>t in a?q(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e;var b=(a,t,e)=>K(a,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const o of n)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function e(n){const o={};return n.integrity&&(o.integrity=n.integrity),n.referrerPolicy&&(o.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?o.credentials="include":n.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(n){if(n.ep)return;n.ep=!0;const o=e(n);fetch(n.href,o)}})();class Z{constructor(t){b(this,"ctx");b(this,"width",0);b(this,"height",0);b(this,"scaleX",1);b(this,"scaleY",1);b(this,"logicalWidth",100);b(this,"logicalHeight",100);b(this,"margin",10);this.ctx=t.getContext("2d"),this.resize(t.width,t.height)}resize(t,e){this.width=t,this.height=e;const s=e-2*this.margin;this.scaleY=s/this.logicalHeight,this.scaleX=this.scaleY;const n=t-2*this.margin;this.logicalWidth=n/this.scaleX}clear(){this.ctx.clearRect(0,0,this.width,this.height)}toScreen(t,e){return{x:this.margin+t*this.scaleX,y:this.margin+(this.logicalHeight-e)*this.scaleY}}toLogical(t,e){const s=(t-this.margin)/this.scaleX,n=this.logicalHeight-(e-this.margin)/this.scaleY;return{x:s,y:n}}drawGrid(){this.ctx.strokeStyle="#e0e0e0",this.ctx.lineWidth=1,this.ctx.beginPath();for(let s=0;s<=this.logicalWidth;s+=10){const n=this.toScreen(s,0),o=this.toScreen(s,this.logicalHeight);this.ctx.moveTo(n.x,n.y),this.ctx.lineTo(o.x,o.y)}for(let s=0;s<=this.logicalHeight;s+=10){const n=this.toScreen(0,s),o=this.toScreen(this.logicalWidth,s);this.ctx.moveTo(n.x,n.y),this.ctx.lineTo(o.x,o.y)}this.ctx.stroke(),this.ctx.strokeStyle="#000";const t=this.toScreen(0,this.logicalHeight),e=this.toScreen(this.logicalWidth,0);this.ctx.strokeRect(t.x,t.y,e.x-t.x,e.y-t.y)}drawSegment(t){const e=this.toScreen(t.p1.x,t.p1.y),s=this.toScreen(t.p2.x,t.p2.y);this.ctx.strokeStyle="#000",this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.moveTo(e.x,e.y),this.ctx.lineTo(s.x,s.y),this.ctx.stroke(),this.ctx.fillStyle="#000",this.ctx.beginPath(),this.ctx.arc(e.x,e.y,3,0,Math.PI*2),this.ctx.arc(s.x,s.y,3,0,Math.PI*2),this.ctx.fill()}drawRect(t,e="rgba(0, 255, 0, 0.3)"){const s=this.toScreen(t.x,t.y+t.height),n=this.toScreen(t.x+t.width,t.y);this.ctx.fillStyle=e,this.ctx.fillRect(s.x,s.y,n.x-s.x,n.y-s.y),this.ctx.strokeStyle="green",this.ctx.lineWidth=2,this.ctx.strokeRect(s.x,s.y,n.x-s.x,n.y-s.y)}drawSplitLine(t,e){if(this.ctx.strokeStyle="red",this.ctx.setLineDash([5,5]),this.ctx.lineWidth=1,this.ctx.beginPath(),e){const s=this.toScreen(t,0),n=this.toScreen(t,this.logicalHeight);this.ctx.moveTo(s.x,s.y),this.ctx.lineTo(n.x,n.y)}else{const s=this.toScreen(0,t),n=this.toScreen(this.logicalWidth,t);this.ctx.moveTo(s.x,s.y),this.ctx.lineTo(n.x,n.y)}this.ctx.stroke(),this.ctx.setLineDash([])}drawActiveWindow(t){const e=this.toScreen(t.x,t.y+t.height),s=this.toScreen(t.x+t.width,t.y);this.ctx.strokeStyle="blue",this.ctx.lineWidth=1,this.ctx.setLineDash([5,5]),this.ctx.strokeRect(e.x,e.y,s.x-e.x,s.y-e.y),this.ctx.setLineDash([])}}class p{constructor(t,e){this.p1=t,this.p2=e}get minX(){return Math.min(this.p1.x,this.p2.x)}get maxX(){return Math.max(this.p1.x,this.p2.x)}get minY(){return Math.min(this.p1.y,this.p2.y)}get maxY(){return Math.max(this.p1.y,this.p2.y)}get slope(){return this.p1.x===this.p2.x?1/0:(this.p2.y-this.p1.y)/(this.p2.x-this.p1.x)}get intercept(){return this.p1.x===this.p2.x?NaN:this.p1.y-this.slope*this.p1.x}getY(t){return Math.abs(this.p1.x-this.p2.x)<1e-9?Math.max(this.p1.y,this.p2.y):this.slope*t+this.intercept}getX(t){return Math.abs(this.p1.y-this.p2.y)<1e-9?Math.max(this.p1.x,this.p2.x):isFinite(this.slope)?(t-this.intercept)/this.slope:this.p1.x}}function J(a){return a.width*a.height}class tt{constructor(t){this.segments=t}getX(t){for(const e of this.segments)if(t>=e.domainMin-1e-9&&t<=e.domainMax+1e-9)return e.seg.getX(t);if(this.segments.length>0){if(t<this.segments[0].domainMin)return this.segments[0].seg.getX(this.segments[0].domainMin);if(t>this.segments[this.segments.length-1].domainMax)return this.segments[this.segments.length-1].seg.getX(this.segments[this.segments.length-1].domainMax)}return NaN}getMinX(t,e){let s=1/0;const n=Math.min(t,e),o=Math.max(t,e);let i=!1;for(const c of this.segments){const h=c.domainMin,l=c.domainMax,r=Math.max(h,n),x=Math.min(l,o);if(r<=x+1e-9){i=!0;const u=c.seg.getX(r),g=c.seg.getX(x);s=Math.min(s,u,g)}}return i?s:NaN}getMaxX(t,e){let s=-1/0;const n=Math.min(t,e),o=Math.max(t,e);let i=!1;for(const c of this.segments){const h=c.domainMin,l=c.domainMax,r=Math.max(h,n),x=Math.min(l,o);if(r<=x+1e-9){i=!0;const u=c.seg.getX(r),g=c.seg.getX(x);s=Math.max(s,u,g)}}return i?s:NaN}}class et{constructor(t,e,s){this.intervals=[];const n=new p({x:s,y:t},{x:s,y:e});this.intervals.push({seg:n,domainMin:t,domainMax:e})}addConstraint(t,e,s,n){const o=[];for(const c of this.intervals){const h=Math.max(c.domainMin,t),l=Math.min(c.domainMax,e);if(h>l+1e-9){o.push(c);continue}c.domainMin<h-1e-9&&o.push({...c,domainMax:h});const r=this.resolveOverlap(c.seg,s,h,l,n);o.push(...r),c.domainMax>l+1e-9&&o.push({...c,domainMin:l})}this.intervals=o}resolveOverlap(t,e,s,n,o){const i=(s+n)/2,c=e.getX(s),h=t.getX(s),l=e.getX(n),r=t.getX(n),x=o?c<h:c>h,u=o?l<r:l>r;if(x&&u)return[{seg:e,domainMin:s,domainMax:n}];if(!x&&!u)return[{seg:t,domainMin:s,domainMax:n}];const g=this.getLine(t),f=this.getLine(e);let m=i;if(Math.abs(g.m-f.m)>1e-9&&(m=(f.c-g.c)/(g.m-f.m)),m>s+1e-9&&m<n-1e-9)return[{seg:x?e:t,domainMin:s,domainMax:m},{seg:u?e:t,domainMin:m,domainMax:n}];{const v=e.getX(i),S=t.getX(i);return[{seg:(o?v<S:v>S)?e:t,domainMin:s,domainMax:n}]}}getLine(t){if(Math.abs(t.p1.y-t.p2.y)<1e-9)return{m:0,c:Math.max(t.p1.x,t.p2.x)};if(Math.abs(t.p1.x-t.p2.x)<1e-9)return{m:0,c:t.p1.x};const e=(t.p2.x-t.p1.x)/(t.p2.y-t.p1.y),s=t.p1.x-e*t.p1.y;return{m:e,c:s}}}function st(a){const t=a.rows(),e=new Array(t).fill(0);if(t===0||a.cols()===0)return e;const s=Array.from({length:t},(o,i)=>i),n=[];for(n.push({rows:s,c_min:0,c_max:a.cols()-1});n.length>0;){const o=n.pop(),{rows:i,c_min:c,c_max:h}=o;if(i.length===0)continue;const l=Math.floor(i.length/2),r=i[l];let x=-1,u=-1e300;const g=Math.max(0,c),f=Math.min(a.cols()-1,h);for(let m=g;m<=f;m++){const v=a.valueAt(r,m);v>u&&(u=v,x=m)}if(e[r]=x,l+1<i.length){const m=i.slice(l+1);n.push({rows:m,c_min:x,c_max:h})}if(l>0){const m=i.slice(0,l);n.push({rows:m,c_min:c,c_max:x})}}return e}class nt{constructor(){this.bestRect={x:0,y:0,width:0,height:0},this.maxArea=0}*solveGenerator(t,e){const s=this.obstaclesToSegments(t,e);return yield*this.solveSegmentsGenerator(s,e),this.bestRect}solveSegments(t,e){const s=this.solveSegmentsGenerator(t,e);let n=s.next();for(;!n.done;)n=s.next();return this.bestRect}*solveSegmentsGenerator(t,e){this.bestRect={x:0,y:0,width:0,height:0},this.maxArea=0;const s=[];for(s.push({window:e,segments:t,type:"VP"}),yield{type:"START",window:e};s.length>0;){const n=s.pop();if(n.segments.length===0){this.updateMaxArea(n.window);continue}n.type==="VP"?yield*this.processVerticalSplit(n,s):yield*this.processHorizontalSplit(n,s)}return yield{type:"FINISHED"},this.bestRect}*processVerticalSplit(t,e){const{window:s,segments:n}=t;if(s.width<.1)return;const o=U(n,s.x,s.x+s.width,!0);let i=o.length>0?o[Math.floor(o.length/2)]:s.x+s.width/2;yield{type:"SPLIT_VP",window:s,splitVal:i};const c={...s,width:i-s.x};if(c.width>1e-6){const l=n.filter(r=>r.minX<i+1e-9);e.push({window:c,segments:l,type:"VP"})}const h={...s,x:i,width:s.x+s.width-i};if(h.width>1e-6){const l=n.filter(r=>r.maxX>i-1e-9);e.push({window:h,segments:l,type:"VP"})}e.push({window:s,segments:n,type:"HP",splitX:i})}*processHorizontalSplit(t,e){const{window:s,segments:n,splitX:o}=t;if(s.height<.1)return;const i=U(n,s.y,s.y+s.height,!1);let c=i.length>0?i[Math.floor(i.length/2)]:s.y+s.height/2;yield{type:"SPLIT_HP",window:s,splitVal:c};const h={...s,y:c,height:s.y+s.height-c};if(h.height>1e-6){const x=n.filter(u=>u.maxY>c-1e-9);e.push({window:h,segments:x,type:"HP",splitX:o})}const l={...s,height:c-s.y};if(l.height>1e-6){const x=n.filter(u=>u.minY<c+1e-9);e.push({window:l,segments:x,type:"HP",splitX:o})}yield{type:"SOLVE_CENTRAL",window:s};const r=it(n,s,{x:o,y:c});this.updateMaxArea(r)}updateMaxArea(t){const e=J(t);e>this.maxArea&&(this.maxArea=e,this.bestRect=t)}obstaclesToSegments(t,e){const s=[];for(const n of t){const o={x:n.x,y:n.y},i={x:n.x+n.width,y:n.y},c={x:n.x+n.width,y:n.y+n.height},h={x:n.x,y:n.y+n.height};s.push(new p(o,i)),s.push(new p(i,c)),s.push(new p(c,h)),s.push(new p(h,o))}return s.push(new p({x:e.x,y:e.y},{x:e.x+e.width,y:e.y})),s.push(new p({x:e.x+e.width,y:e.y},{x:e.x+e.width,y:e.y+e.height})),s.push(new p({x:e.x+e.width,y:e.y+e.height},{x:e.x,y:e.y+e.height})),s.push(new p({x:e.x,y:e.y+e.height},{x:e.x,y:e.y})),s}}function U(a,t,e,s){const n=[];for(const i of a){const c=s?i.p1.x:i.p1.y,h=s?i.p2.x:i.p2.y;c>=t-1e-9&&c<=e+1e-9&&n.push(c),h>=t-1e-9&&h<=e+1e-9&&n.push(h)}n.sort((i,c)=>i-c);const o=[];if(n.length>0){o.push(n[0]);for(let i=1;i<n.length;i++)n[i]>n[i-1]+1e-6&&o.push(n[i])}return o.filter(i=>i>t+1e-9&&i<e-1e-9)}function it(a,t,e){const s=O(a,1,e,t),n=O(a,2,e,t),o=O(a,3,e,t),i=O(a,4,e,t);return ht(s,n,o,i,e)}function O(a,t,e,s){const n=t===1||t===4,o=t===1||t===2,i=Math.min(o?e.y:s.y,o?s.y+s.height:e.y),c=Math.max(o?e.y:s.y,o?s.y+s.height:e.y),h=t===1||t===4?e.x:s.x,l=t===1||t===4?s.x+s.width:e.x,r=n?s.x+s.width:s.x,x=new et(i,c,r),u=1e-9;for(const g of a){if(g.maxY<i||g.minY>c||g.maxX<h||g.minX>l)continue;const f=Math.abs(g.p1.y-g.p2.y)<u,m=Math.abs(g.p1.x-g.p2.x)<u;f?at(g,x,h,l,i,c,n):m?ot(g,x,h,l,i,c,n):ct(g,x,h,l,i,c,n)}return new tt(x.intervals)}function ot(a,t,e,s,n,o,i){const c=a.p1.x,h=1e-9;if(c<e-h||c>s+h)return;const l=Math.max(a.minY,n),r=Math.min(a.maxY,o);l<r+h&&t.addConstraint(l,r,a,i)}function at(a,t,e,s,n,o,i){const c=Math.max(a.minX,e),h=Math.min(a.maxX,s),l=1e-9;if(c>h+l)return;const r=i?c:h,x=new p({x:r,y:a.minY},{x:r,y:a.maxY}),u=Math.max(a.minY,n),g=Math.min(a.maxY,o);u<g+l&&t.addConstraint(u,g,x,i)}function ct(a,t,e,s,n,o,i){const c=a.slope,h=a.intercept,l=c*e+h,r=c*s+h,x=Math.min(l,r),u=Math.max(l,r),g=Math.max(a.minY,n,x),f=Math.min(a.maxY,o,u);g<f+1e-9&&t.addConstraint(g,f,a,i)}function ht(a,t,e,s,n){let o=0,i={x:n.x,y:n.y,width:0,height:0};const c=G(a.segments,t.segments),h=G(e.segments,s.segments);if(c.length===0||h.length===0)return i;const l=(u,g)=>{const f=c[u],m=h[g],v=(E,B)=>{if(E<=B)return 0;const L=n.y,w=1e-5,k=a.getMinX(L,E-w),C=s.getMinX(B+w,L),Y=t.getMaxX(L,E-w),D=e.getMaxX(B+w,L);if(isNaN(k)||isNaN(C)||isNaN(Y)||isNaN(D))return 0;const z=Math.min(k,C),_=Math.max(Y,D);return z<=_?0:(z-_)*(E-B)};let S=-1;const P=4;for(let E=0;E<=P;E++){const B=f.min+(f.max-f.min)*E/P;for(let L=0;L<=P;L++){const w=m.min+(m.max-m.min)*L/P;S=Math.max(S,v(B,w))}}return{area:S}},r={rows:()=>c.length,cols:()=>h.length,valueAt:(u,g)=>l(u,g).area},x=st(r);for(let u=0;u<c.length;u++){const g=x[u],f=r.valueAt(u,g);if(f>o){o=f;const m=c[u],v=h[g],S=n.y,P=4;for(let E=0;E<=P;E++){const B=m.min+(m.max-m.min)*E/P;for(let L=0;L<=P;L++){const w=v.min+(v.max-v.min)*L/P;if(B<=w)continue;const k=1e-5,C=Math.min(a.getMinX(S,B-k),s.getMinX(w+k,S)),Y=Math.max(t.getMaxX(S,B-k),e.getMaxX(w+k,S));if(C>Y){const D=(C-Y)*(B-w);D>=o-1e-9&&(o=D,i={x:Y,y:w,width:C-Y,height:B-w})}}}}}return i}function G(a,t){const e=[];let s=0,n=0;for(;s<a.length&&n<t.length;){const o=a[s],i=t[n],c=Math.max(o.domainMin,i.domainMin),h=Math.min(o.domainMax,i.domainMax);c<h-1e-9&&e.push({min:c,max:h,s1:o.seg,s2:i.seg}),o.domainMax<i.domainMax?s++:n++}return e}class lt{constructor(){b(this,"obstacles",[]);b(this,"bounds",{x:0,y:0,width:100,height:100});b(this,"result",null);b(this,"solver");b(this,"undoStack",[]);b(this,"redoStack",[]);b(this,"MAX_HISTORY",50);b(this,"solverStep",null);b(this,"iterator",null);b(this,"isDebugging",!1);this.solver=new nt}snapshot(){this.undoStack.push({obstacles:[...this.obstacles],result:this.result?{...this.result}:null}),this.undoStack.length>this.MAX_HISTORY&&this.undoStack.shift(),this.redoStack=[]}undo(){if(this.undoStack.length===0)return;this.redoStack.push({obstacles:[...this.obstacles],result:this.result?{...this.result}:null});const t=this.undoStack.pop();this.obstacles=t.obstacles,this.result=t.result}redo(){if(this.redoStack.length===0)return;this.undoStack.push({obstacles:[...this.obstacles],result:this.result?{...this.result}:null});const t=this.redoStack.pop();this.obstacles=t.obstacles,this.result=t.result}canUndo(){return this.undoStack.length>0}canRedo(){return this.redoStack.length>0}addObstacle(t){this.snapshot(),this.obstacles.push(t),this.result=null}setObstacles(t){this.snapshot(),this.obstacles=t,this.result=null}clear(){this.snapshot(),this.obstacles=[],this.result=null}solve(){this.snapshot();const t=performance.now();this.result=this.solver.solveSegments(this.obstacles,this.bounds);const e=performance.now();return this.isDebugging=!1,this.solverStep=null,{time:e-t,area:this.result?this.result.width*this.result.height:0}}startDebug(){this.iterator=this.solver.solveSegmentsGenerator(this.obstacles,this.bounds),this.isDebugging=!0,this.result=null,this.nextStep()}nextStep(){if(!this.iterator)return;const t=this.iterator.next();t.done?(this.result=t.value,this.iterator=null,this.isDebugging=!1,this.solverStep={type:"FINISHED"}):this.solverStep=t.value}loadUShape(){const t=this.bounds.width,e=this.bounds.height;this.setObstacles([new p({x:t*.2,y:e*.2},{x:t*.2,y:e*.8}),new p({x:t*.2,y:e*.2},{x:t*.8,y:e*.2}),new p({x:t*.8,y:e*.2},{x:t*.8,y:e*.8})])}loadCross(){const t=this.bounds.width,e=this.bounds.height;this.setObstacles([new p({x:t*.5,y:e*.2},{x:t*.5,y:e*.8}),new p({x:t*.2,y:e*.5},{x:t*.8,y:e*.5})])}loadRandom(t=10){const e=[],n=this.bounds.width-10,o=this.bounds.height-10;for(let i=0;i<t;i++){const c=Math.random()*(n-10)+10,h=Math.random()*(o-10)+10,l=Math.random()*15+5,r=Math.random()*Math.PI*2,x=c+Math.cos(r)*l,u=h+Math.sin(r)*l;e.push(new p({x:c,y:h},{x,y:u}))}this.setObstacles(e)}loadComb(){const t=this.bounds.width,e=this.bounds.height,s=[],n=10,o=t/(n+1);for(let i=1;i<=n;i++){const c=i*o;i%2===0?s.push(new p({x:c,y:0},{x:c,y:e*.8})):s.push(new p({x:c,y:e},{x:c,y:e*.2}))}this.setObstacles(s)}loadSpiral(){const t=this.bounds.width,e=this.bounds.height,s=t/2,n=e/2,o=[],i=20;let c=s,h=n,l=i,r=0;const x=Math.max(t,e);for(;l<x+i;){let u=c,g=h;r===0?u+=l:r===1?g+=l:r===2?u-=l:r===3&&(g-=l);const f=Math.max(0,Math.min(t,u)),m=Math.max(0,Math.min(e,g)),v=Math.max(0,Math.min(t,c)),S=Math.max(0,Math.min(e,h));(Math.abs(f-v)>.1||Math.abs(m-S)>.1)&&o.push(new p({x:v,y:S},{x:f,y:m})),c=u,h=g,r=(r+1)%4,(r===0||r===2)&&(l+=i)}this.setObstacles(o)}loadMaze(){const t=this.bounds.width,e=this.bounds.height,s=8,n=8,o=t/s,i=e/n,c=[];for(let h=1;h<s;h++)for(let l=0;l<n;l++)Math.random()>.4&&c.push(new p({x:h*o,y:l*i},{x:h*o,y:(l+1)*i}));for(let h=1;h<n;h++)for(let l=0;l<s;l++)Math.random()>.4&&c.push(new p({x:l*o,y:h*i},{x:(l+1)*o,y:h*i}));this.setObstacles(c)}loadStaircase(){const t=this.bounds.width,e=this.bounds.height,s=10,n=[];for(let o=0;o<s;o++){const i=o/s*t,c=e-o/s*e,h=(o+1)/s*t,l=c,r=e-(o+1)/s*e;n.push(new p({x:i,y:c},{x:h,y:l})),n.push(new p({x:h,y:l},{x:h,y:r}))}this.setObstacles(n)}loadDense(){this.loadRandom(50)}loadStar(){const t=this.bounds.width,e=this.bounds.height,s=t/2,n=e/2,o=Math.min(t,e)*.4,i=[],c=12;for(let h=0;h<c;h++){const l=h/c*Math.PI*2;i.push(new p({x:s,y:n},{x:s+Math.cos(l)*o,y:n+Math.sin(l)*o}))}this.setObstacles(i)}setBounds(t,e){this.bounds={x:0,y:0,width:t,height:e}}}const rt=document.querySelector("#app");rt.innerHTML=`
  <div class="sidebar">
    <div class="sidebar-header">
      MER Visualizer
    </div>
    
    <div class="control-group">
      <div class="control-group-title">Actions</div>
      <div class="grid-2">
         <button id="undoBtn" class="secondary" disabled title="Undo (Ctrl+Z)">Undo</button>
         <button id="redoBtn" class="secondary" disabled title="Redo (Ctrl+Y)">Redo</button>
      </div>
      <button id="solveBtn" class="primary">Solve MER</button>
      <button id="clearBtn">Clear All</button>
      <button id="randomBtn">Randomize</button>
    </div>

    <div class="control-group">
      <div class="control-group-title">Debug</div>
      <button id="debugBtn">Start Debug Session</button>
      <div id="debugControls" style="display:none; gap: 5px; margin-top: 5px;">
        <button id="nextBtn" style="flex:1;">Next</button>
        <button id="playBtn" style="flex:1;">Play</button>
        <button id="stopBtn" class="secondary" style="flex:1;">Stop</button>
      </div>
    </div>

    <div class="control-group">
      <div class="control-group-title">Presets</div>
      <div class="grid-2">
          <button id="uShapeBtn" title="Load standard U-Shape test case">U-Shape</button>
          <button id="crossBtn" title="Load Cross shape test case">Cross</button>
          <button id="combBtn" title="Load Comb (interleaving bars)">Comb</button>
          <button id="spiralBtn" title="Load Square Spiral">Spiral</button>
          <button id="mazeBtn" title="Load Random Grid Maze">Maze</button>
          <button id="staircaseBtn" title="Load Staircase (monotonic)">Staircase</button>
          <button id="denseBtn" title="Load 50 random segments">Dense</button>
          <button id="starBtn" title="Load Star (radiating lines)">Star</button>
      </div>
    </div>

    <div class="stats" id="stats">
      Ready.<br>
      Obstacles: 0
    </div>

    <div class="sidebar-footer">
      <a href="https://github.com/claimred/mer-algorithm" target="_blank" rel="noopener noreferrer" title="View Source on GitHub">
        <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor">
          <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
        </svg>
        <span>View Source</span>
      </a>
      <span class="version">v1.0.1</span>
    </div>
  </div>
  <div class="main">
    <canvas id="canvas"></canvas>
  </div>
`;const R=document.querySelector("#canvas"),dt=document.querySelector("#stats"),Q=document.querySelector("#undoBtn"),$=document.querySelector("#redoBtn"),X=new Z(R),d=new lt;let N=!1,I=null,T={x:0,y:0};function j(){const a=R.parentElement;a&&(R.width=a.clientWidth,R.height=a.clientHeight,X.resize(R.width,R.height),d.setBounds(X.logicalWidth,X.logicalHeight),y())}const ut=new ResizeObserver(()=>j());ut.observe(R.parentElement);j();function y(){X.clear(),X.drawGrid();for(const a of d.obstacles)X.drawSegment(a);if(d.result&&X.drawRect(d.result),d.isDebugging&&d.solverStep&&(d.solverStep.window&&X.drawActiveWindow(d.solverStep.window),d.solverStep.splitVal!==void 0)){const a=d.solverStep.type==="SPLIT_VP";X.drawSplitLine(d.solverStep.splitVal,a)}N&&I&&X.drawSegment(new p(I,T))}function M(a){dt.innerHTML=`
      Obstacles: ${d.obstacles.length}<br>
      ${a||""}
    `,Q.disabled=!d.canUndo(),$.disabled=!d.canRedo()}R.addEventListener("mousedown",a=>{N=!0;const t=R.getBoundingClientRect();I=X.toLogical(a.clientX-t.left,a.clientY-t.top),T={...I}});R.addEventListener("mousemove",a=>{if(!N)return;const t=R.getBoundingClientRect();T=X.toLogical(a.clientX-t.left,a.clientY-t.top),y()});R.addEventListener("mouseup",()=>{N&&I&&(d.addObstacle(new p(I,T)),N=!1,I=null,y(),M())});function F(){d.canUndo()&&(d.undo(),y(),M("Undone."))}function V(){d.canRedo()&&(d.redo(),y(),M("Redone."))}Q.addEventListener("click",F);$.addEventListener("click",V);window.addEventListener("keydown",a=>{(a.ctrlKey||a.metaKey)&&(a.key==="z"?(a.preventDefault(),a.shiftKey?V():F()):a.key==="y"&&(a.preventDefault(),V()))});const W=document.getElementById("debugControls");let H=null;function A(){H&&(clearInterval(H),H=null)}document.getElementById("debugBtn").addEventListener("click",()=>{var a;A(),d.startDebug(),W.style.display="flex",y(),M(`Debugging... Step: ${(a=d.solverStep)==null?void 0:a.type}`)});document.getElementById("nextBtn").addEventListener("click",()=>{var a,t,e;A(),d.isDebugging&&(d.nextStep(),y(),d.isDebugging?M(`Step: ${(e=d.solverStep)==null?void 0:e.type}`):(W.style.display="none",M(`Finished. Area: ${((a=d.result)==null?void 0:a.width)*((t=d.result)==null?void 0:t.height)}`)))});document.getElementById("playBtn").addEventListener("click",()=>{H||(H=window.setInterval(()=>{var a;d.isDebugging?(d.nextStep(),y(),M(`Step: ${(a=d.solverStep)==null?void 0:a.type}`),d.isDebugging||(A(),W.style.display="none")):A()},100))});document.getElementById("stopBtn").addEventListener("click",()=>{A(),d.isDebugging=!1,d.iterator=null,W.style.display="none",y(),M("Debug stopped.")});document.getElementById("solveBtn").addEventListener("click",()=>{A();const a=d.solve();y(),M(`Area: ${a.area.toFixed(2)}<br>Time: ${a.time.toFixed(2)}ms`)});document.getElementById("clearBtn").addEventListener("click",()=>{d.clear(),y(),M()});document.getElementById("randomBtn").addEventListener("click",()=>{d.loadRandom(),y(),M()});document.getElementById("uShapeBtn").addEventListener("click",()=>{d.loadUShape(),y(),M()});document.getElementById("crossBtn").addEventListener("click",()=>{d.loadCross(),y(),M()});document.getElementById("combBtn").addEventListener("click",()=>{d.loadComb(),y(),M()});document.getElementById("spiralBtn").addEventListener("click",()=>{d.loadSpiral(),y(),M()});document.getElementById("mazeBtn").addEventListener("click",()=>{d.loadMaze(),y(),M()});document.getElementById("staircaseBtn").addEventListener("click",()=>{d.loadStaircase(),y(),M()});document.getElementById("denseBtn").addEventListener("click",()=>{d.loadDense(),y(),M()});document.getElementById("starBtn").addEventListener("click",()=>{d.loadStar(),y(),M()});y();
