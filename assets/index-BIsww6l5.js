var j=Object.defineProperty;var U=(c,t,e)=>t in c?j(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var b=(c,t,e)=>U(c,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const i of n)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function e(n){const i={};return n.integrity&&(i.integrity=n.integrity),n.referrerPolicy&&(i.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?i.credentials="include":n.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(n){if(n.ep)return;n.ep=!0;const i=e(n);fetch(n.href,i)}})();class q{constructor(t){b(this,"ctx");b(this,"width",0);b(this,"height",0);b(this,"scaleX",1);b(this,"scaleY",1);b(this,"logicalSize",100);b(this,"margin",10);this.ctx=t.getContext("2d"),this.resize(t.width,t.height)}resize(t,e){this.width=t,this.height=e;const s=Math.min(t,e)-2*this.margin;this.scaleX=s/this.logicalSize,this.scaleY=s/this.logicalSize}clear(){this.ctx.clearRect(0,0,this.width,this.height)}toScreen(t,e){const s=this.logicalSize*this.scaleX,n=this.logicalSize*this.scaleY,i=(this.width-s)/2,o=(this.height-n)/2;return{x:i+t*this.scaleX,y:o+(this.logicalSize-e)*this.scaleY}}toLogical(t,e){const s=this.logicalSize*this.scaleX,n=this.logicalSize*this.scaleY,i=(this.width-s)/2,o=(this.height-n)/2,a=(t-i)/this.scaleX,l=this.logicalSize-(e-o)/this.scaleY;return{x:a,y:l}}drawGrid(){this.ctx.strokeStyle="#e0e0e0",this.ctx.lineWidth=1,this.ctx.beginPath();for(let t=0;t<=100;t+=10){const e=this.toScreen(t,0),s=this.toScreen(t,100);this.ctx.moveTo(e.x,e.y),this.ctx.lineTo(s.x,s.y);const n=this.toScreen(0,t),i=this.toScreen(100,t);this.ctx.moveTo(n.x,n.y),this.ctx.lineTo(i.x,i.y)}this.ctx.stroke(),this.ctx.strokeStyle="#000",this.ctx.strokeRect(this.toScreen(0,100).x,this.toScreen(0,100).y,this.logicalSize*this.scaleX,this.logicalSize*this.scaleY)}drawSegment(t){const e=this.toScreen(t.p1.x,t.p1.y),s=this.toScreen(t.p2.x,t.p2.y);this.ctx.strokeStyle="#000",this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.moveTo(e.x,e.y),this.ctx.lineTo(s.x,s.y),this.ctx.stroke(),this.ctx.fillStyle="#000",this.ctx.beginPath(),this.ctx.arc(e.x,e.y,3,0,Math.PI*2),this.ctx.arc(s.x,s.y,3,0,Math.PI*2),this.ctx.fill()}drawRect(t,e="rgba(0, 255, 0, 0.3)"){const s=this.toScreen(t.x,t.y+t.height),n=this.toScreen(t.x+t.width,t.y);this.ctx.fillStyle=e,this.ctx.fillRect(s.x,s.y,n.x-s.x,n.y-s.y),this.ctx.strokeStyle="green",this.ctx.lineWidth=2,this.ctx.strokeRect(s.x,s.y,n.x-s.x,n.y-s.y)}drawSplitLine(t,e){if(this.ctx.strokeStyle="red",this.ctx.setLineDash([5,5]),this.ctx.lineWidth=1,this.ctx.beginPath(),e){const s=this.toScreen(t,0),n=this.toScreen(t,100);this.ctx.moveTo(s.x,s.y),this.ctx.lineTo(n.x,n.y)}else{const s=this.toScreen(0,t),n=this.toScreen(100,t);this.ctx.moveTo(s.x,s.y),this.ctx.lineTo(n.x,n.y)}this.ctx.stroke(),this.ctx.setLineDash([])}drawActiveWindow(t){const e=this.toScreen(t.x,t.y+t.height),s=this.toScreen(t.x+t.width,t.y);this.ctx.strokeStyle="blue",this.ctx.lineWidth=1,this.ctx.setLineDash([5,5]),this.ctx.strokeRect(e.x,e.y,s.x-e.x,s.y-e.y),this.ctx.setLineDash([])}}class S{constructor(t,e){this.p1=t,this.p2=e}get minX(){return Math.min(this.p1.x,this.p2.x)}get maxX(){return Math.max(this.p1.x,this.p2.x)}get minY(){return Math.min(this.p1.y,this.p2.y)}get maxY(){return Math.max(this.p1.y,this.p2.y)}get slope(){return this.p1.x===this.p2.x?1/0:(this.p2.y-this.p1.y)/(this.p2.x-this.p1.x)}get intercept(){return this.p1.x===this.p2.x?NaN:this.p1.y-this.slope*this.p1.x}getY(t){return Math.abs(this.p1.x-this.p2.x)<1e-9?Math.max(this.p1.y,this.p2.y):this.slope*t+this.intercept}getX(t){return Math.abs(this.p1.y-this.p2.y)<1e-9?Math.max(this.p1.x,this.p2.x):isFinite(this.slope)?(t-this.intercept)/this.slope:this.p1.x}}function H(c){return c.width*c.height}class K{constructor(t){this.segments=t}getX(t){for(const e of this.segments)if(t>=e.domainMin-1e-9&&t<=e.domainMax+1e-9)return e.seg.getX(t);if(this.segments.length>0){if(t<this.segments[0].domainMin)return this.segments[0].seg.getX(this.segments[0].domainMin);if(t>this.segments[this.segments.length-1].domainMax)return this.segments[this.segments.length-1].seg.getX(this.segments[this.segments.length-1].domainMax)}return NaN}getMinX(t,e){let s=1/0;const n=Math.min(t,e),i=Math.max(t,e);let o=!1;for(const a of this.segments){const l=a.domainMin,p=a.domainMax,x=Math.max(l,n),g=Math.min(p,i);if(x<=g+1e-9){o=!0;const M=a.seg.getX(x),d=a.seg.getX(g);s=Math.min(s,M,d)}}return o?s:NaN}getMaxX(t,e){let s=-1/0;const n=Math.min(t,e),i=Math.max(t,e);let o=!1;for(const a of this.segments){const l=a.domainMin,p=a.domainMax,x=Math.max(l,n),g=Math.min(p,i);if(x<=g+1e-9){o=!0;const M=a.seg.getX(x),d=a.seg.getX(g);s=Math.max(s,M,d)}}return o?s:NaN}}class J{constructor(t,e,s){this.intervals=[];const n=new S({x:s,y:t},{x:s,y:e});this.intervals.push({seg:n,domainMin:t,domainMax:e})}addConstraint(t,e,s,n){const i=[];for(const o of this.intervals){const a=Math.max(o.domainMin,t),l=Math.min(o.domainMax,e);if(a<=l+1e-9){o.domainMin<a-1e-9&&i.push({...o,domainMax:a});const p={seg:o.seg,domainMin:a,domainMax:l},x=(a+l)/2,g=o.seg.getX(x),M=s.getX(x),d=n?s.getX(a)<o.seg.getX(a):s.getX(a)>o.seg.getX(a),r=n?s.getX(l)<o.seg.getX(l):s.getX(l)>o.seg.getX(l);if(d&&r)p.seg=s;else if(!(!d&&!r)){const h=this.getLine(o.seg),v=this.getLine(s);let f=a;if(Math.abs(h.m-v.m)>1e-9?f=(v.c-h.c)/(h.m-v.m):f=x,f>a+1e-9&&f<l-1e-9){const m=d?s:o.seg,y=r?s:o.seg;i.push({seg:m,domainMin:a,domainMax:f}),i.push({seg:y,domainMin:f,domainMax:l}),o.domainMax>l&&i.push({...o,domainMin:l});continue}else(n?M<g:M>g)&&(p.seg=s)}i.push(p),o.domainMax>l&&i.push({...o,domainMin:l})}else i.push(o)}this.intervals=i}getLine(t){if(Math.abs(t.p1.y-t.p2.y)<1e-9)return{m:0,c:Math.max(t.p1.x,t.p2.x)};if(Math.abs(t.p1.x-t.p2.x)<1e-9)return{m:0,c:t.p1.x};const e=(t.p2.x-t.p1.x)/(t.p2.y-t.p1.y),s=t.p1.x-e*t.p1.y;return{m:e,c:s}}}function Z(c){const t=c.rows(),e=new Array(t).fill(0);if(t===0||c.cols()===0)return e;const s=Array.from({length:t},(i,o)=>o),n=[];for(n.push({rows:s,c_min:0,c_max:c.cols()-1});n.length>0;){const i=n.pop(),{rows:o,c_min:a,c_max:l}=i;if(o.length===0)continue;const p=Math.floor(o.length/2),x=o[p];let g=-1,M=-1e300;const d=Math.max(0,a),r=Math.min(c.cols()-1,l);for(let h=d;h<=r;h++){const v=c.valueAt(x,h);v>M&&(M=v,g=h)}if(e[x]=g,p+1<o.length){const h=o.slice(p+1);n.push({rows:h,c_min:g,c_max:l})}if(p>0){const h=o.slice(0,p);n.push({rows:h,c_min:a,c_max:g})}}return e}class tt{constructor(){this.steps=[],this.bestRect={x:0,y:0,width:0,height:0},this.maxArea=0}*solveGenerator(t,e){const s=[];for(const n of t){const i={x:n.x,y:n.y},o={x:n.x+n.width,y:n.y},a={x:n.x+n.width,y:n.y+n.height},l={x:n.x,y:n.y+n.height};s.push(new S(i,o)),s.push(new S(o,a)),s.push(new S(a,l)),s.push(new S(l,i))}return s.push(new S({x:e.x,y:e.y},{x:e.x+e.width,y:e.y})),s.push(new S({x:e.x+e.width,y:e.y},{x:e.x+e.width,y:e.y+e.height})),s.push(new S({x:e.x+e.width,y:e.y+e.height},{x:e.x,y:e.y+e.height})),s.push(new S({x:e.x,y:e.y+e.height},{x:e.x,y:e.y})),yield*this.solveSegmentsGenerator(s,e),this.bestRect}*solveSegmentsGenerator(t,e){this.bestRect={x:0,y:0,width:0,height:0},this.maxArea=0;const s=[];for(s.push({window:e,segments:t,type:"VP"}),yield{type:"START",window:e};s.length>0;){const n=s.pop(),{window:i,segments:o,type:a,splitX:l}=n;if(o.length===0){const p=H(i);p>this.maxArea&&(this.maxArea=p,this.bestRect=i);continue}if(a==="VP"){if(i.width<.1)continue;const p=Q(o,i.x,i.x+i.width,!0);let x=0;if(p.length>0){const d=Math.floor(p.length/2);x=p[d]}else x=i.x+i.width/2;yield{type:"SPLIT_VP",window:i,splitVal:x};const g={...i,width:x-i.x};if(g.width>1e-6){const d=o.filter(r=>r.minX<x+1e-9);s.push({window:g,segments:d,type:"VP"})}const M={...i,x,width:i.x+i.width-x};if(M.width>1e-6){const d=o.filter(r=>r.maxX>x-1e-9);s.push({window:M,segments:d,type:"VP"})}s.push({window:i,segments:o,type:"HP",splitX:x})}else{if(i.height<.1)continue;const p=Q(o,i.y,i.y+i.height,!1);let x=0;if(p.length>0){const v=Math.floor(p.length/2);x=p[v]}else x=i.y+i.height/2;const g=l;yield{type:"SPLIT_HP",window:i,splitVal:x};const M={...i,y:x,height:i.y+i.height-x};if(M.height>1e-6){const v=o.filter(f=>f.maxY>x-1e-9);s.push({window:M,segments:v,type:"HP",splitX:g})}const d={...i,height:x-i.y};if(d.height>1e-6){const v=o.filter(f=>f.minY<x+1e-9);s.push({window:d,segments:v,type:"HP",splitX:g})}yield{type:"SOLVE_CENTRAL",window:i};const r=et(o,i,{x:g,y:x}),h=H(r);h>this.maxArea&&(this.maxArea=h,this.bestRect=r)}}return yield{type:"FINISHED"},this.bestRect}solveSegments(t,e){const s=this.solveSegmentsGenerator(t,e);let n=s.next();for(;!n.done;)n=s.next();return this.bestRect}}function Q(c,t,e,s){const n=[];for(const o of c){const a=s?o.p1.x:o.p1.y,l=s?o.p2.x:o.p2.y;a>=t-1e-9&&a<=e+1e-9&&n.push(a),l>=t-1e-9&&l<=e+1e-9&&n.push(l)}n.sort((o,a)=>o-a);const i=[];if(n.length>0){i.push(n[0]);for(let o=1;o<n.length;o++)n[o]>n[o-1]+1e-6&&i.push(n[o])}return i.filter(o=>o>t+1e-9&&o<e-1e-9)}function et(c,t,e){const s=T(c,1,e,t),n=T(c,2,e,t),i=T(c,3,e,t),o=T(c,4,e,t);return st(s,n,i,o,e)}function T(c,t,e,s){const n=t===1||t===4,i=t===1||t===2,o=i?e.y:s.y,a=i?s.y+s.height:e.y,l=n?s.x+s.width:s.x,p=new J(Math.min(o,a),Math.max(o,a),l),x=Math.min(o,a),g=Math.max(o,a),M=t===1||t===4?e.x:s.x,d=t===1||t===4?s.x+s.width:e.x,r=1e-9;for(const h of c){if(h.maxY<x||h.minY>g||h.maxX<M||h.minX>d)continue;let v=Math.max(h.minY,x),f=Math.min(h.maxY,g);if(!(v>f+r)){if(Math.abs(h.p1.x-h.p2.x)<r){const m=h.p1.x;if(m<M-r||m>d+r)continue}else{const m=h.getX(v),y=h.getX(f),w=Math.min(m,y);if(Math.max(m,y)<M-r||w>d+r)continue;let L=-1/0,X=1/0;L=Math.max(L,x,h.minY),X=Math.min(X,g,h.maxY);const B=h.slope,P=h.intercept;if(Math.abs(B)>r){const A=B*M+P,V=B*d+P,F=Math.min(A,V),G=Math.max(A,V);L=Math.max(L,F),X=Math.min(X,G)}v=L,f=X}v<f+r&&p.addConstraint(v,f,h,n)}}return new K(p.intervals)}function st(c,t,e,s,n){let i=0,o={x:n.x,y:n.y,width:0,height:0};const a=_(c.segments,t.segments),l=_(e.segments,s.segments);if(a.length===0||l.length===0)return o;const p={rows:()=>a.length,cols:()=>l.length,valueAt:(g,M)=>{const d=a[g],r=l[M];let h=-1;const v=(m,y)=>{if(!d.s1||!d.s2||!r.s1||!r.s2||m<=y)return 0;const w=n.y,I=c.getMinX(w,m),L=s.getMinX(y,w),X=t.getMaxX(w,m),B=e.getMaxX(y,w);if(isNaN(I)||isNaN(L)||isNaN(X)||isNaN(B))return 0;const P=Math.min(I,L),A=Math.max(X,B);return P<=A?0:(P-A)*(m-y)},f=(m,y)=>{const w=v(m,y);w>h&&(h=w)};f(d.min,r.min),f(d.min,r.max),f(d.max,r.min),f(d.max,r.max);for(let m=0;m<=4;m++)for(let y=0;y<=4;y++)f(d.min+(d.max-d.min)*m/4,r.min+(r.max-r.min)*y/4);return h}},x=Z(p);for(let g=0;g<a.length;g++){const M=x[g],d=p.valueAt(g,M);if(d>i){i=d;const r=a[g],h=l[M],v=(m,y)=>{if(!r.s1||!r.s2||!h.s1||!h.s2||m<=y)return 0;const w=n.y,I=c.getMinX(w,m),L=s.getMinX(y,w),X=t.getMaxX(w,m),B=e.getMaxX(y,w);if(isNaN(I)||isNaN(L)||isNaN(X)||isNaN(B))return 0;const P=Math.min(I,L),A=Math.max(X,B);return P<=A?0:(P-A)*(m-y)},f=(m,y)=>{const w=v(m,y);if(w>=i-1e-9){const I=n.y,L=Math.min(c.getMinX(I,m),s.getMinX(y,I)),X=Math.max(t.getMaxX(I,m),e.getMaxX(y,I));o={x:X,y,width:L-X,height:m-y},i=w}};f(r.min,h.min),f(r.min,h.max),f(r.max,h.min),f(r.max,h.max);for(let m=0;m<=4;m++)for(let y=0;y<=4;y++)f(r.min+(r.max-r.min)*m/4,h.min+(h.max-h.min)*y/4)}}return o}function _(c,t){const e=[];let s=0,n=0;for(;s<c.length&&n<t.length;){const i=c[s],o=t[n],a=Math.max(i.domainMin,o.domainMin),l=Math.min(i.domainMax,o.domainMax);a<l-1e-9&&e.push({min:a,max:l,s1:i.seg,s2:o.seg}),i.domainMax<o.domainMax?s++:n++}return e}class nt{constructor(){b(this,"obstacles",[]);b(this,"bounds",{x:0,y:0,width:100,height:100});b(this,"result",null);b(this,"solver");b(this,"solverStep",null);b(this,"iterator",null);b(this,"isDebugging",!1);this.solver=new tt}addObstacle(t){this.obstacles.push(t),this.result=null}setObstacles(t){this.obstacles=t,this.result=null}clear(){this.obstacles=[],this.result=null}solve(){const t=performance.now();this.result=this.solver.solveSegments(this.obstacles,this.bounds);const e=performance.now();return this.isDebugging=!1,this.solverStep=null,{time:e-t,area:this.result?this.result.width*this.result.height:0}}startDebug(){this.iterator=this.solver.solveSegmentsGenerator(this.obstacles,this.bounds),this.isDebugging=!0,this.result=null,this.nextStep()}nextStep(){if(!this.iterator)return;const t=this.iterator.next();t.done?(this.result=t.value,this.iterator=null,this.isDebugging=!1,this.solverStep={type:"FINISHED"}):this.solverStep=t.value}loadUShape(){this.setObstacles([new S({x:20,y:20},{x:20,y:80}),new S({x:20,y:20},{x:80,y:20}),new S({x:80,y:20},{x:80,y:80})])}loadCross(){this.setObstacles([new S({x:50,y:20},{x:50,y:80}),new S({x:20,y:50},{x:80,y:50})])}loadRandom(t=10){const e=[];for(let s=0;s<t;s++){const n=Math.random()*80+10,i=Math.random()*80+10,o=Math.random()*10+5;Math.random()>.5?e.push(new S({x:n,y:i},{x:n+o,y:i})):e.push(new S({x:n,y:i},{x:n,y:i+o}))}this.setObstacles(e)}}const it=document.querySelector("#app");it.innerHTML=`
  <div class="sidebar">
    <h2>MER Visualizer</h2>
    
    <div class="controls">
    <div class="controls">
      <h3>Actions</h3>
      <button id="solveBtn">Solve</button>
      <button id="clearBtn" class="secondary">Clear</button>
      <button id="randomBtn" class="secondary">Randomize</button>
    </div>

    <div class="controls">
      <h3>Debug</h3>
      <button id="debugBtn">Start Debug</button>
      <div id="debugControls" style="display:none; gap: 5px; margin-top: 5px;">
        <button id="nextBtn" style="flex:1;">Next</button>
        <button id="playBtn" style="flex:1;">Play</button>
        <button id="stopBtn" class="secondary" style="flex:1;">Stop</button>
      </div>
    </div>


    <div class="controls">
      <h3>Presets</h3>
      <button id="uShapeBtn" class="secondary">U-Shape</button>
      <button id="crossBtn" class="secondary">Cross</button>
    </div>

    <div class="stats" id="stats">
      Ready.<br>
      Obstacles: 0
    </div>
    
    <h3>Instructions</h3>
    <small>Drag on canvas to draw lines.</small>
  </div>
  <div class="main">
    <canvas id="canvas"></canvas>
  </div>
`;const Y=document.querySelector("#canvas"),ot=document.querySelector("#stats"),N=new q(Y),u=new nt;function $(){Y.width=Y.parentElement.clientWidth,Y.height=Y.parentElement.clientHeight,N.resize(Y.width,Y.height),R()}window.addEventListener("resize",$);$();function R(){N.clear(),N.drawGrid();for(const c of u.obstacles)N.drawSegment(c);if(u.result&&N.drawRect(u.result),u.isDebugging&&u.solverStep&&(u.solverStep.window&&N.drawActiveWindow(u.solverStep.window),u.solverStep.splitVal!==void 0)){const c=u.solverStep.type==="SPLIT_VP";N.drawSplitLine(u.solverStep.splitVal,c)}z&&D&&N.drawSegment(new S(D,O))}function E(c){ot.innerHTML=`
      Obstacles: ${u.obstacles.length}<br>
      ${c||""}
    `}let z=!1,D=null,O={x:0,y:0};Y.addEventListener("mousedown",c=>{z=!0;const t=Y.getBoundingClientRect();D=N.toLogical(c.clientX-t.left,c.clientY-t.top),O={...D}});Y.addEventListener("mousemove",c=>{if(!z)return;const t=Y.getBoundingClientRect();O=N.toLogical(c.clientX-t.left,c.clientY-t.top),R()});Y.addEventListener("mouseup",()=>{z&&D&&(u.addObstacle(new S(D,O)),z=!1,D=null,R(),E())});const W=document.getElementById("debugControls");let k=null;function C(){k&&(clearInterval(k),k=null)}document.getElementById("debugBtn").addEventListener("click",()=>{var c;C(),u.startDebug(),W.style.display="flex",R(),E(`Debugging... Step: ${(c=u.solverStep)==null?void 0:c.type}`)});document.getElementById("nextBtn").addEventListener("click",()=>{var c,t,e;C(),u.isDebugging&&(u.nextStep(),R(),u.isDebugging?E(`Step: ${(e=u.solverStep)==null?void 0:e.type}`):(W.style.display="none",E(`Finished. Area: ${((c=u.result)==null?void 0:c.width)*((t=u.result)==null?void 0:t.height)}`)))});document.getElementById("playBtn").addEventListener("click",()=>{k||(k=window.setInterval(()=>{var c;u.isDebugging?(u.nextStep(),R(),E(`Step: ${(c=u.solverStep)==null?void 0:c.type}`),u.isDebugging||(C(),W.style.display="none")):C()},100))});document.getElementById("stopBtn").addEventListener("click",()=>{C(),u.isDebugging=!1,u.iterator=null,W.style.display="none",R(),E("Debug stopped.")});document.getElementById("solveBtn").addEventListener("click",()=>{C();const c=u.solve();R(),E(`Area: ${c.area.toFixed(2)}<br>Time: ${c.time.toFixed(2)}ms`)});document.getElementById("clearBtn").addEventListener("click",()=>{u.clear(),R(),E()});document.getElementById("randomBtn").addEventListener("click",()=>{u.loadRandom(),R(),E()});document.getElementById("uShapeBtn").addEventListener("click",()=>{u.loadUShape(),R(),E()});document.getElementById("crossBtn").addEventListener("click",()=>{u.loadCross(),R(),E()});R();
